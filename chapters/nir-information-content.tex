%!TEX root = ../thesis.tex
% NIR-information

\chapter{NIR information}

\label{cha:nir_content}

\section{Overview}

The pursuit of detecting exoplanets, especially ``habitable'' and ``Earth-like'' planets, requires state-of-the-art instrumentation with high precision. One of the key detection methods, the Radial Velocity (RV) method, measures the wobble induced on the Star by the planet as they orbit their common barycentre \reference{rv method}.  {\red{} add Some stuff about mass and period from pedros paper}



A increase in the number of \nir{} spectrographs is increasing to focus on cooler M-dwarfs stars which have a easier* chance of detecting Earth-like planets in the habitable zone. \change{Check mission statements for these}{SPIRou, NIRPS} and CARMENES. Also CRIRES+...
This work continues the assessment of RV precision levels possible in this domain.
\todo{For example from Figueira 2016 see figure) A more precise measurement can be achieved from X band then the Y band... or in order XYZ of precision}

\missingfigure{An example from Figueira et al. 2016}



This work is not directly related to detecting exoplanet atmospheres themselves but investigates the theoretical and observed RV precision of M-dwarf spectra in the NIR. This has previously helped the aid the direction of instrument design by identifying the wavelength regions with the best RV precision \citep{figueira_radial_2016} but can also help in the planning of observations, by understanding how the precision changes with spectral type and observed SNR. This can help in detecting the presence of ``habitable Earth-like'' planets around M-dwarfs which will likely have their atmospheres evenutally probed.


\section{Radial velocity precision}
The first detections of planets with the RV technique \textbf{Queloz 2995} discovered the mass and close in hot-Jupiter planets. These are the easiest to detect with the highest RV amplitude.

Over the years the community has push the limits of this technique to smaller and smaller planetary masses. An example is shown in Fig.~\ref{fig:year_mass}.
\begin{figure}

\includegraphics[width=0.8\linewidth]{figures/year_planet_mass.png}
\caption{Mass of discovered planets verse year. From Exoplanet.eu}
\label{fig:year_mass}
\end{figure}


RV amplitude scales with mass of the star $M_\star^{-2/3}$ and with the planetary orbital period $P_\textrm{orb}^{-2/3}$.

The detection of an Earth-mass planet inside the habitable zone around a solar-type star, the RV amplitude is 10 cm/s. If that a planet with the same characteristics is instead orbiting a M/ -dwarf, the RV amplitude is larger than 1 m/s. This is due to two factors, the smaller mass of the host star, and the closer habitable zone, due to a lower luminosity output of the host)

\citet{artigau_optical_2018} recently compared archival spectra of Barnard's Star, an M-dwarf, and found that state-of-the-art atmosphere models over-predict the $Y$ and $J$-band RV content by more than a factor of $\sim$$2$, while under-predicting the $H$ and $K$-band content by half.
{\red{} in this work we find similar?}

We are currently aiming to extend this work over the whole M-dwarf range, from M0-M9.


History of Precision calculations:
Connes 1985 -
Bouchy et al. 2001  - photon noise limit on rv measurements.
Figueria et al. 2016 - focus on m-dwarfs parameter range to specify new instrumentation windows to focus.
Reiners 2017 -  Carmenes sample. some precision
pedros school section other precision source r\^1.5


\subsection{Fundamental photon noise limitation}

A optimum technique to calculate the radial velocity precision of a spectrum using the full spectral information is proposed by~\citet{Connes1985}. Here we provide the radial velocity precision derivation following~\citet{Connes1985, bouchy_fundamental_2001, figueira_radial_2016}. A majority of this derivation comes from~\citet{bouchy_fundamental_2001} with some extra notes added to improve the clarity.

For each spectrum there is assigned a quality factor, Q, to compute the fundamental uncertainty on the radial velocity measurements due to noise. {\red{} i am not sure what i am trying to say in this sentence}\unfinished{Change picture spectral range to capital lambda $\Lambda$}

\begin{figure}
    \centering
    %\includegraphics[width=0.7\linewidth]{figures/spectrum_example_a}
   % \includegraphics[width=0.7\linewidth]{figures/precision_derivation.pdf}
    \includegraphics[width=0.7\linewidth]{figures/precision_derivation.png}
    \caption{Arbitrary spectral line with a shift $\delta \lambda$, inspired by~\citet{Connes1985}.  \(\Lambda\) is the wavelength range considered.}
    \label{fig:precisionderivation}
\end{figure}

The Doppler shift of a spectrum is given by:
\begin{equation}
\frac{\delta V}{c} = \frac{\delta \lambda}{\lambda}.
\label{eq:dopplershift}
\end{equation}
Here $c$ is the speed of light in a vacuum, and $\delta \lambda$ is the observed shift in wavelength $\lambda$ caused by the velocity $\delta V$

Using basic calculus \(\delta y = \frac{\partial y}{\partial x} \delta x,  \nonumber\) and for a Doppler shift that is small compared to the line-width\footnote{Although~\citet{Connes1985} show that this approximation in Eq.\,\ref{eq:intensitychange} is adequate under all circumstances}, the observable intensity change at a given pixel can be expressed by:

\begin{equation}
\delta A(i) = A(i) - A_0(i) \simeq \frac{\partial A_0(i)}{\partial \lambda} \delta \lambda
\label{eq:intensitychange}
\end{equation}

Rearranging Eq.~\ref{eq:intensitychange} for \(\delta \lambda\) and putting it into Eq.~\ref{eq:dopplershift}, the Doppler shift of then becomes:
\begin{equation}
    \frac{\delta V(i)}{c} = \frac{A(i) - A_0(i) }{\lambda(i) (\partial A_0(i)/\partial \lambda(i))} \label{eq:delta_v_i}
\end{equation}

This equation shows that the changes in velocity is measured through a change in intensity in the recorded spectrum, \(A(i)-A_0(i)\), and inversely proportional to the slope of the spectrum, \(\partial A_0(i)/\partial \lambda(i))\).
This equation provides a measurement of the radial velocity shift for each pixel (i) in the spectrum. The whole available spectral range, $\Sigma$, should be used to increase the sensitivity of the measurement and decrease the noise. This is achieved by summing the contribution of all pixels using an optimal weight W(i).

\begin{equation}
\frac{\delta V}{c} = \frac{\Sigma{ \frac{\delta V(i)}{c}W(i)}}{\Sigma {W(i)}}
\end{equation}

Statistically, the optimal weights are proportional to the inverse square of the individual dispersion,


\begin{equation}
W(i) = \frac{1}{\left(\frac{\delta V_{RMS}(i)}{c}\right)^2},  \label{eq:weights}
\end{equation}
where $X_{RMS}$ is the dispersion on the quantity $X$.


The individual dispersion of the velocity change measure $\delta V_{RMS}(i)$ is the dispersion of radial velocity resulting from several measurements of the reference spectrum all with the same Doppler shift (e.g. zero). Equation.\,\ref{eq:delta_v_i} thus becomes:
\begin{equation}
    \frac{\delta V(i)}{c} = \frac{{[A(i) - A_0(i)]}_{RMS} }{\lambda(i) (\partial A_0(i)/\partial \lambda(i))} \label{eq:delta_v_i_rms}
\end{equation}
The noise of the spectrum A is the quadratic sum of the photon noise \(\sqrt{A}\) and the detector noise \(\sigma_D\). The spectrum \(A_0\) is considered noise free.

\begin{equation}
[A(i)-A_0(i)]_{RMS} = [A(i)]_{RMS} = \sqrt{\sqrt{A(i)}^2 + \sigma^2_{D}} \label{eq:noise}
\end{equation}
We can set \(A = A_0\) if we consider the Doppler shift is small and that \(A\) and \(A_0\) have the same intensity level. Using Eq.\,\ref{eq:weights},\,\ref{eq:delta_v_i} and\,\ref{eq:noise}	the optimum weights then become solely dependent on the reference spectrum.



\begin{equation}
W(i) =   \frac{\lambda^2(i)  (\partial A_0(i)/\partial \lambda(i))^{2}}{A(i) + {\sigma}^{2}_{D}} \label{eq:optimal_weight}
\end{equation}
This weighting function can be modified to mask out and eliminate unwanted lines in the spectrum. For instance in the removal of telluric absorption lines in observed spectra. This is achieved to setting the particular pixel weights to zero.

With the optimal weights set the velocity change measured from the full spectral range \(\Lambda\), \unfinished{Change picture spectral range} is given by:


\begin{eqnarray}
    \frac{\delta V(i)}{c} &= \frac{
    	\Sigma{
        	\frac{
            	A(i) - A_0(i)}{
                \lambda(i) \left(\partial A_0(i)/\partial \lambda(i)\right)} W(i)}}{
             \Sigma {W(i)}} \\
    &= \frac{
    	\Sigma  {
        	(\frac
            	{A(i) - A_0(i)}
                {\lambda(i) (\partial A_0(i)/\partial \lambda(i))}) \frac
                	{\lambda^2(i)  (\partial A_0(i)/\partial \lambda(i))^{2}}
                    {A(i) + {\sigma}^{2}_{D}}
                 }
         }
    {\frac
    	{\lambda^2(i)  (\partial A_0(i)/\partial \lambda(i))^{2}}{A(i) + {\sigma}^{2}_{D}}
        } \\
    &=
    \label{eq:delta_v_eqarray}
\end{eqnarray}\unfinished {Finish this equation (9 of bouchy 2001)}
\unfinished{Try the symbolic package from PC}

The important quantity for RV measurements is not only the velocity value itself but the dispersion on the measured velocity or the precision, \(\delta V_{RMS}\). From equation \ref{eq:weights} the dispersion is given by :


\begin{equation}
    \frac{\delta V_{RMS}}{c} = \frac{1}{\Sigma {\,W(i)}} = \frac{1}{Q \Sigma {\,A_0(i)}} \label{eq:dv_rms}
\end{equation}
With this the velocity precision is inversely proportional to the sum of the optimal pixel weights.

A spectral quality factor, Q, is defined as for the pure photon noise case, as in~\cite{Connes1985, connes_demonstration_1996}.

\begin{equation}
Q = \frac{\sqrt{\Sigma{\,W(i)}}}{\sqrt{\Sigma{\,A_0(i)}}}.
\end{equation}
This factor is flux independent and is purely a function of the spectral profile within the spectral range considered. It is is a measure of the line richness. For example a spectra with many sharp lines will have a high Q. This quality factor is valid for the pure photon noise case only.

With this quality factor the uncertainty in the velocity change can be rearranged in terms of the spectral quality;

\begin{equation}
    \delta V_{RMS} = \frac{c}{Q \sqrt{\Sigma {\,A_0(i)}}} = \frac{c}{Q \sqrt{{N}_{{e}^{-}}}},
\end{equation}

where \(\Sigma A_0(i) = {N}_{{e}^{-}}\) is considered to be the total number of photo electrons \({N}_{{e}^{-}}\) counted in the whole spectral range considered.
From the spectral quality factor and the number of photons collect the fundamental velocity precision can be determined.

The spectral quality depends on the spectral profile of the target as well as the instrumental resolution of the spectrograph (which induces line broadening). The number of photoelectrons counted  \(N_{e^{-}}\) depends on the stellar magnitude, detector efficiency and integration time. It can be estimated using
 \begin{equation}
 N_{e^{-}} = P_{avg} * S_{tel} * T_{exp} * \alpha* \Lambda,
 \end{equation}

where \(P_{avg}\) is the average monochromatic stellar brightness
across the wavelength range \(\Lambda\) in

\si{\photons\per\second\per\centi\metre\squared\per\centi\metre},

\(S_{tel}\) is the telescope collecting area in \si{\centi\metre\squared},

\(T_{exp}\) is the integration time in \si{\second},

and \(\alpha\) the overall efficiency (including atmosphere, telescope, spectrograph and detector).

 This can be used to determine the RV precision for a given instrument, and be useful in exposure time calculators for planing observations.

In the case of several \(\delta V\) measurements computed for \(k\) spectral slices (or spectral orders) then the error on the average \(\delta V\) is given by the error on a weighted average:
\begin{equation}
\overline{\delta {V}_{RMS}} = \frac{1}{\sqrt{\Sigma_k{(\frac{1}{\delta V_{RMS}(k)})^2}}}
\end{equation}


We follow~\cite{figueira_radial_2016} by exclusively considering a high signal-to-noise regime in which $A(i) + D^2 \sim A(i)$ can be approximated.


\footnote{ pure detector noise the fluctuation are independent of the spectrum \(A\) and the quality factor for pure detector noise is \(Q_D = \frac{\Sigma{\lambda^2 {(\partial A_0(i)/\partial \lambda(i))}^{2}}}{\Sigma{\, A_0(i)}}\) as derived by~\cite{Connes1985}. }

The in the photon noise limited case we assume that all measurements have same RV then the the the object has not
\citet{Connes1985} show that the optimal weights for photon limited noise is given by.....

There is also a optimal weight for detector noise but we are always assume we are in high SNR case and are photon noise limited.


This technique has been tested and demonstrated on observations by~\citet{connes_demonstration_1996} and been used to determine predict the accuracy or performance limits of spectrograph instrumentation~\citet{Connes1985,bouchy_fundamental_2001} and can influence the design (or use) of spectrographs
 (e.g. SPIROU~\citep{artigau_spirou_2014,figueira_radial_2016})
\unfinished{Does spectrograph pipelines such as HARPS use these equations to measure estimate/precision?}


Considering that \(\Sigma{A_0(i)} = N_{e^-} \) is the total number of photoelectrons counted over the whole spectral range then the uncertainty in the velocity change is finally given by:

\begin{equation}
\frac{\delta V_{RMS}}{c} = \frac{c}{Q \sqrt{N_{e^-}}} \approx \frac{c}{Q (S/N)},
\end{equation}

where the \(SNR=\sqrt{N_{e^-}} \)for large N. \unfinished{It is convenient to use this version when comparing observed spectra with different S/N.?}




\subsection{Prepare phoenix aces models}:
\# see~\citet{figueira_radial_2016}

Convert SED to counts.


Scale to 100 SNR per resolution element in J band.

Convolutions


Since the synthetic models do not have a consistent wavelength grid, the discretization of the convolution kernel onto the changing wavelength grid causes each pixel to be multiplied by a slightly different kernel area. We therefore divide the result by a convolution of a spectrum of ones with the same wavelength resolution.

Differences to Figueria et al.

%-----------------------------------
%	SUBSECTION 2
%-----------------------------------

Preparation of Carmenes spectra.


\missingfigure{Example of CARMENES spectra before and after correction}

\subsection{Bands}
The bands are selected based on the strong water absorption. This can be seen the Carmenes spectra in Figure~\ref{}\todo{Add figure here}. The wavelength ranges used in this work \citet{figueira_radial_2016} and used in this work are given in Table~\ref{tab:band_ranges}.
\begin{table}
    \centering
    \caption{The wavelength ranges of the \nir{} spectral bands.}
    \begin{tabular}{cc}
        \toprule
        Band & Range (\um{})\\
        \midrule
        Z & 0.83 -- 0.93\\
        Y & 1.00 -- 1.10\\
        J & 1.17 -- 1.33\\
        H & 1.50 -- 1.75\\
        K & 2.07 -- 2.35\\
        \bottomrule
    \end{tabular}
    \label{tab:band_ranges}
\end{table}



\subsection{Comparing models to Carmenes.}
Already somewhat done in Reiners. (use all spectra). They measured the precision obtained in the spectra.

Band by band like Figueria 2016?
Certain\% steps like Bouchy or Artigau


Can do Barnard's star in CARMENES. compared to models in Artigau.

\DTLsetseparator{,}
\DTLloadrawdb{targets}{data/carmenes_selection.csv}%

\begin{table*}[b]
    \centering
    \caption{CARMENES library target selection spanning the M-Dwarf spectral range.}
    \begin{tabular}{l l l r c c c c}%
        \toprule
        Karmn & Name & SpT &  $\textrm{SNR}_{\textrm{NIR}}$  & Temp (K) & logg & [Fe/H] & v$\sin{i}$ (km/s)\\
        \midrule
        \DTLforeach*{targets}{\id=Karmn,\name=Name,\sptype=SpT,\snr=NIR-SNR,\teff=Teff, \logg=logg,\metal=FeH, \rot=ROT-Vsini}{
            \DTLiffirstrow{}{\\}\id & \name &\sptype & \snr & \teff & \logg & \metal & \rot
        }
        \\
        \bottomrule
    \end{tabular}
    \label{tab:targets}
\end{table*}

\input{tables/carmenes_selection.tex}
%\input{tables/carmenes_selection_transpose.tex}

\section{Metallicity logg effects}
We explore the effect of metallicity and logg on the spectral quality of spectra in the PHOENIX-ACES library by extending the quality factor and precisions computation to [Fe/H] -1--1 and logg 4.0--5.5. In figure \ref{fig:deviations} show the variation of quality factor with broadening of R=100000 and vsini=1.0 km/s across the M-dwarf spectral types and the \nir{} bands. We observed multiple different effects present.


The Z band has a large separation in spectral quality due to spectral type, this is because the continuum the Z band is severely eroded in the spectra of late M's as they cool. Each spectral type also behaves very differently to a change in [Fe/H] and logg. For M0 and M3 there is an increase with [Fe/H] below solar metallicity, above solar metallicity the slopes of the lines dramatically increase, especially for M3. For M6 and M9 there is a step slope with [Fe/H] below solar metallicity, which flattens off at solar metallicity, and even decreases for the M9 spectra above solar metallicity.
As logg increases in the Z band there is a decrease in quality. There is a consistently large separation between early and late M's that. The quality for M6 is very shallow, while for M9 the quality is nearly flat for logg = 4.0 and 4.5 but then decreases sharply at higher logg.

Y band -\\

J band - \\

For the H and K band there is fairly consistent linear trend for all spectral types, with the quality factor increasing with an increase in [Fe/H] and decreasing with an increase in logg. There is also only a relatively small variation in quality factor due to the spectral type.



\begin{figure}
\includegraphics[width=0.99\linewidth]{figures/information-content/metalicity_effect.pdf}\\
\includegraphics[width=0.99\linewidth]{figures/information-content/logg_effect.pdf}
\caption{Quality factor changes across spectral type and bands for variations in [Fe/H] and logg. Broadening values are R=100000 and vsini = 1.0 km/s. Top: Quality factor variation of [Fe/H] between -1.0 to 1.0 at a fixed logg=4.5. Bottom: Quality factor variation of logg between 4 and 5.5 with fixed [Fe/H]=0.0. Note a higher quality factor corresponds to an increased RV precision.}
\label{fig:deviations}
\end{figure}

%----------------------------------------------------------------------------------------
%	SECTION 2
%----------------------------------------------------------------------------------------

\section{Main Section 2}



\section{Updating RV precision software}
A large section of this work involved optimizing the original code used in \citet{figueira_radial_2016}.
Care needs to be taken to optimize the code. The original code used in \citet{figueira_radial_2016} was slow, taking around 2 hours per simulation, this led to multiple weeks of processing time to compute the precision's for the original paper.

In this section we document the changes made to the code in the course of improving it. 

\subsection{Automated testing}
To insure that any changes made to the code did not change the underling results. This involved writing automatic tests for the software. This practice is crucial in computer science ins commercial software development but seldom done in research but is becoming more popular. \reference{works of software testing in research.}
Some work focused on testing ideology from computer science. Although not perfect implementation I began by adding automated tests to the code to check individual parts of it.
Before making changes I created automated tests that would confirm the functionality of pieces of the code. I could then make changes to the code, to improve the performance without worrying that the results were different.
Namely that the same precision were calculated in the end. 

Functional test and unit tests.

\subsection{Atmospheric masking bug}
One thing that was revealed in testing was that there was an error in the application of Condition\#2. When the telluric mask was shifted to account for barycentric motion of the earth, and the condition of 3 consecutive pixels in the telluric spectra being lower than the limit (due to the higher sampling) there was an software bug, 


A check for this issue was discovered using this unit test.
\begin{lstlisting}[language=Python, caption=Example unit test to catch masking bug.]
def test_telluric_masking(wavelength, transmission):
    mask = telluric_mask(transmission, depth=0.98)
    mask = barycenter_shift(mask)
   
    # Checks that the mask is still masking out all telluric lines.
    assert np.all(transmission[mask] > 0.98)
\end{lstlisting}
The assert statements checks that when the mask is applied to the transmission spectrum again all of the values are outside of any deep telluric regions. A test like this would have caught this bug.

This bug means that all the RV precision values for Condition \#2 published in \citet{figueira_radial_2016} incorrect. As the applied masking was unevenly applied \citet{figueira_radial_2016} the new values RV precision values do not all change in the same proportion or direction. Some specific wavelengths and resolutions are essentially unchanged while other results change by over 20\mps.  Even though there is an error with condition \#2 they do not change the overall conclusions of the paper. These are...\todo{add conclusions not affected}

 \subsection{Performance}
 
     There was a major performance bottleneck in the convolution stage, which increased the performance around 250X itself. The algorithm looped though the pixels in the spectrum, selecting out the necessary section around a given pixel with a comprehension list (for loop if inside range). Turning the result into a numpy array, performing the sum for that pixel and appending it to a list.


caching convolution result to prevent recomputing the same values. Joblib.  Also embarrassingly parallel so added multiprocessing support.

The convolution is still the slowest part. There are other methods that work on uniform spectra, which have not been tried to see how they affect the performance or RV precision results.
\textbf{Insert code samples.}


\subsection{Model extension}


The solution is to iterate over each pixel but create a mask array and use numpy indexing to select the required pixel span. (this remains in numpy )
These operations all remain in numpy so do not waste time converting between lists and numpy arrays, in which Python need to constantly check and convert the type of each item.

This shows a lesson in the usefulness of test driven development, or testing of code in science.


An normalization step was originally done after the convolution, to normalize out the effect of the convolution on a spectrum of 1s, due to the changing wavelength grids sampling. This was brought inside the main convolution by dividing the pixel by the convolution of a spectrum of ones at the same time. (again in numpy so it is quick)

Parallelization as embarrassingly parallel, the result of each pixel is independent of result of neighbours.

This is not a criticism of the work done by the original author (my supervisor). It is easier to modify a working system then to create one from scratch.

Computer code is not the important part in scientific exploration., although becoming more important in open source and reproducibility efforts. Often forgotten in

\# Handle any phoenix aces models.


\section{Numerical Gradient}
One of the key insights from Equations~\ref{eq:optimal_weight} and \ref{eq:dv_rms} is that the radial velocity error is inversely proportional gradient of the spectra, In numerically computing the RV precision, the result is dependent on the numerical method used to compute the gradient. In this section we explore the affect of improving the precision of the numerical gradient on the final RV precisions.

The simplest way to calculate the derivative using finite difference methods \citep{quarteroni_numerical_2000}. These arising from the Newton's definition of the derivative for a continuous function $f(x)$ which should be familiar from introductory calculus:
\[f'(x) = \lim_{h \to 0} \frac{f(x+h)-f(x)}{h}~.\]

There are three main varieties of the finite difference,  
 \[FFD = \frac{f(x+h)-f(x)}{h},  CFD=\frac{f(x+\frac{1}{2}h)-f(x-\frac{1}{2}h)}{h}, BFD=\frac{f(x)-f(x-h)}{h}\,,\] called the forwards (FFD), central (CFD), and backwards (BFD) finite differences respectively.

The order of uncertainty on the FFD/BFD is $\mathcal{O}(h)$ while for the CDF it is $\mathcal{O}(h^2)$ \citep{quarteroni_numerical_2000}. As the difference between points (h) is small the central difference gives a more precise value for the gradient at each point.

In our case \(h\) is the difference in wavelength between the two pixels considered. in the FFD case the gradient at pixel \(i\) becomes:
\[\partial A_0(i)/\partial\lambda(i) = \frac{A_0(i+1) - A_0(i)}{\lambda(i+1)-\lambda(i)}\]
At each pixel the numerical derivative is evaluated to the average slope between itself and the following point and is an approximation to the derivative. This only extends to \(i= n-1\), and the last pixel is dropped from the RV calculation.\footnote{This is important in the case of Condition #2.}


There are other numerical methods to calculate the derivative. The \emph{gradient}\footnote{\href{https://docs.scipy.org/doc/numpy/reference/generated/numpy.gradient.html\#id1}{https://docs.scipy.org/doc/numpy/reference/generated/numpy.gradient.html\#id1}}  function in Numpy is implemented with central differences in the interior points, accurate to  second order, and first order accurate one-sided (forward or backwards) differences at the boundaries.

In full the central difference approximation for our situation is  ....

approximation of $f_{i}^{(1)}$ is the following:

$\hat f_{i}^{(1)} = \frac{ h_{s}^{2}f\left(x_{i} + h_{d}\right) + \left(h_{d}^{2} - h_{s}^{2}\right)f\left(x_{i}\right) - h_{d}^{2}f\left(x_{i}-h_{s}\right)} { h_{s}h_{d}\left(h_{d} + h_{s}\right)} + \mathcal{O}\left(\frac{h_{d}h_{s}^{2} + h_{s}h_{d}^{2}}{h_{d} + h_{s}}\right)
$


Note that if the spectrum is evenly spaced $h_{s}=h_{d}$ this reduces to the standard second order approximation:

$\hat f_{i}^{(1)}= \frac{f\left(x_{i+1}\right) - f\left(x_{i-1}\right)}{2h} + \mathcal{O}\left(h^{2}\right)$


In \citet{figueira_radial_2016} the slope is calculated using the FFD method.

In \fref{fig:gradients} we show a spectral line and the calculation of the derivative using the first finite difference original used, and the higher precision version incorporated in numpy's gradient function. There a 3 notable differences between the methods.
The first is that there is an offset in gradient as the finite difference evaluates the slope slightly ahead of itself.
Correcting for this offset the points follow the same shape. 


This is the RV precision without any resolution, rotation or each spectra is normalized to a maximum of 1 in the band. Each is only relative to the individual band and not comparable between bands in this instance. Only indicates the relative precision between different gradient methods.

\input{tables/numerical_gradient.tex}

\begin{figure}
    \centering
    \begin{tabular}{cc}
    \includegraphics[width=0.45\linewidth]{figures/information-content/spectra_gradient_example1}& \includegraphics[width=0.45\linewidth]{figures/information-content/spectra_gradient_example2}\\
    \end{tabular}
    \caption{}
    \label{fig:spectragradientexample1}
\end{figure}


\subsection{Masking Function}
As suggested in Connes and Bouchy a masking function can be applied to the pixel weights to account for specific sections or to remove telluric lines. This is essentially what we preform with band selection, assign zeros to everything outside the selected band.
Figueira et al. 2016 chose to use this mask in a round about way. 
They split the spectra on the individual chunks left over  (essentially removing the )
as a visual example the mask in which the zeros are the locations of telluric lines 
[11101111011] splits the spectrum into [[s1, s2, s3], [s5, s6, s7, s8], [s10, s11]].  The RV precision of each individual chunk is calculated and then combined as a weighted error. This is analytically equivalent as applying a mask of 0's to the full spectrum but in practise is not quite. Due to the choice of numerical derivate which is used in the weights there is some differences due to the order of operation. For instance using the FFD then the pixels [s3, s8, s11] do not contributed to the RV precision. Except in the for the slope of the neighbouring pixel. So when the spectrum is split into N chunks due to telluric lines N extra pixels are lost. 
Also when using the new gradient that keeps the last pixel splitting also has an effect as the last pixels will be calculated slope according to the backwards difference, rather than central difference if the weights were calculated first.

These effects are both on an order of 0.1 -- 0.01\%  

\input{tables/mask_ordering}

{
    With the FFD gradient the change in RV error between splitting on telluric lines and masking after calculating the pixel weight is \(\sim\)0.2--0.7\% decrease. This is due to the last point in each split being ignored. 
    Using more precise gradient leads to a difference in RV precision between masked and split  less than ~0.13\% for the NIR bands. With a very slight increase in RV error. This difference is due to the final point in each slice being analysis with backwards difference instead of central differences.
    
    With the effects due to gradient at the last point, it is recommended to calculate the pixel weights first and then split them. Applying a boolean mask to the weights is the easier and better way to apply the telluric masking.
}

We have adjusted the code to apply the masking after the pixel weights are calculated. This retains the most pixels, with the more accurate pixel weights. The overall change in precision between the original method (if it was free of errors) and the new method XXXX \%.

For condition 2 in which there were error there is no meaningful relation between the new and old values.

We can also treat the third condition (in which telluric transmission is fully correct) as a mask function. 

From \eref{condition3} the flux variance is divided by the telluric transmission squared \(T^2\). Rearranging this equation we can turn it into a multiplication. \(WIS_t = T**2 *WIS\). Therefore in the 3 instance we can apply a masking function M = T**2.

Applying it this way simplifies the underlying code. Instead of 3 separate functions to do the 3 different steps It is the same code with 3 different masks. In the program internals the mask is squared so that the telluric transmission can be given. This does not matter for condition 1 in which the mask is all 1s.
If this code is to be run with a different mask  this internal squaring will need to be accounted for for now it handles our three conditions here perfectly.


Condition1 -> M = 1s
Condition2 -> M 1,0 mask
Condition3 -> M = T**2





\subsection{SNR scaling}

To analysis the relative precision of different spectra they need to normalized to a common reference point. In this section we detail how this was originally done and how this was changed to be adaptable to any library spectra.

In the original code this was selected to be a SNR per pixel of 100 at the centre of the \textit{J}-band at 1.25\si{\micro\meter}. The normalization values for each band and vsini/resolution combination were hard-coded into the analysis. This made it impossible to adapt the code to other spectra or parameter combinations.

An automated SNR scaling procedure was created to remove the hard-coded values. This updated code finds the centre point of the band of reference for the given spectrum. Totals the photon count across one resolution element, \(\delta\lambda\), and then takes the square root. This is using the definition of the SNR as \(SNR = \sqrt{N}\) for large N. This value is then used to scale the spectrum such that the SNR at the reference point is the desired value.

\begin{equation}
    SF =  \frac{\sqrt{\Sigma{\delta\lambda} A}} {SNR_{desired}}
\end{equation}
\textit{SF} where \textit{SF} is the scaling factor, \(\Sigma_{\delta\lambda} A\) is the sum of the point in one resolution element and \(SNR_{desired}\) is the desired SNR level requested. 

This automated procedure enabled 3 different features.
- The ability to analysis other spectral models, not just corresponding to M0, M3, M6, M9 spectral types.
- Scaling to a SNR per pixel level other than 100.
    A SNR per pixel other than 100 can be selected.
- Allowing for other sampling levels (if desired)
      Not restricted to a model with 3 samples per resolution element.
- Different reference bands available.
    Results are not limited to being referenced from the \textit{J}-band. For instance the RV precision can now be calculated for a given SNR at the centre of the \textit{K}-band. This was one the features requested for the Exposure Time Calculators precision values. For NIRPS we provided precision values relative to each individual band, while for SPIRou they were relative to the {J}- and {H}-bands.

The default values for the snr scaling a still 100 at the centre of the J band, but there is now options to easily change these values.

The centre of each band was visually checked to ensure that they were there was not a spectral line at the reference locations, which would slightly adjust the SNR scaling level.
 

As shown in the RV precision is inversely proportional to the SNR level. To access the RV precision of any of the values in Table at a different SNR level you can apply the following
\begin{equation}
\rm RV_{SNR2} = RV_{SNR1} * \frac{SNR1}{SNR2} 
\end{equation}


\section{SPIRou and NIRPS ETC}
Having this tool to calculate RV precisions efficiently lead to contributions to the Exposure Time Calculators (ETC) for both the SPIRou and NIRPS spectrographs.

In September 2017 we were requested to provide precision calculations for the SPIRou ETC\footnote{\url{http://www.cfht.hawaii.edu/Instruments/SPIRou/SPIRou_etc.php}}. These were the same table as~\citet{figueira_radial_2016} but with a each band referenced to 100 SNR in its own band. The modification to use the centre of any band was made to fulfil this request. Notes on the telluric correction issue affect on Condition. 2.

In May 2018 we were requested to provide precision calculations for the NIRPS ETC. This extended the spectral range from M0, M3, M6, M9 at 3900. 3500, 2800 2600 K respectively, but to all temperatures between 2500 and 4000K inclusively. This provides a finer resolution coverage over the M spectral type, allowed by the PHOENIX-ACES library.
Instrumental resolutions of 75000 and 100000 were requested to match the NIRPS instrument.
The logg and metallicity, sampling rate remained at the~\citet{figueira_radial_2016} levels of 4.5, 0.0 and 3 respectively.
Precisions were provided for SNR of 100 relative to the J, H bands as well as to each band individually. Artigua 2018. (priv. communication)\todo{Check how to cite priv communication properly} suggested the truly relevant value is the SNR in H band for NIRPS radial velocities.

A table of the precisions created for the NIRPS ETC are provided as an online table to our publication \textit{Neal et al. 2018b (in prep.)}\footnote{Available at \href{blah}{blah}} \unfinished{Inlcude correct links}


These values were both calculated and provided using the old gradient and old masking (with spectral splitting routine). As we show in \sref{} these have a precision $\sim$2--7\% better than the newer value.







\subsection{CODE examples}:

\begin{lstlisting}[language=Python, caption=Python example old]

def pixel_rot_convolution(wl_0, wl, flux, vsini, epsilon):
flux_conv_rot = []
counter=0
for wl_0 in wav_extended:
# select all values such that are within the FWHM limits
delta_wl = wl_0*vsini/3.0e5
mask = [i for i in range(len(wal)) if
((wl_0 - delta_wl) < wl[i] < (wl_0 + delta_wl))]
flux_2convolve = flux[mask[0]:mask[-1]+1]
rotation_profile = rotation_kernel(wl[mask[0]:mask[-1]+1] - wl_0, delta_wl, vsini, epsilon)
flux_conv_rot.append(np.sum(rotation_profile*flux_2convolve))

flux_conv_rot = np.array(flux_conv_rot, dtype="float64")

\end{lstlisting}

These simple examples ignore the edge effects which are incorporated, by extending the wavelength range used by 5 fwhm.
\begin{lstlisting}[language=Python, caption=Python example]

flux_conv_rot = np.empty_like(wl)
for i, wl_0 in enumerate(wl):
"""Rotational convolution for pixel wl_0."""
# select all values such that they are within the fwhm limits
delta_wl = wl_0 * vsini / 3.0e5

mask = (wl > (wl_0 - delta_wl) &  (wl < (wl + delta_wl)))
rotation_profile = rotation_kernel(wl[index_mask] - wl_0, delta_wl, vsini, epsilon)

pixel_conv = np.sum(rotation_profile *  flux[mask]) / np.sum(rotation_profile)
flux_conv_rot[i] = pixel_conv

\end{lstlisting}


\begin{lstlisting}

def rotation_kernel(delta_lambdas: ndarray, delta_lambda_l: float, vsini: float, epsilon: float) -> ndarray:
"""Calculate the rotation kernel for a given wavelength

Parameters
----------
delta_lambdas: array
Wavelength values selected within delta_lambda_l around central value. (check)
delta_lambda_l: float
FWHM of rotational broadening. (check)
vsini: float
Projected rotational velocity [km/s]
epsilon: float
Linear limb-darkening coefficient (0-1).

Returns
-------
Rotational kernel

Notes:
Equations * from .... book.

"""
denominator = (np.pi * vsini * (1.0 - epsilon / 3.0))
lambda_ratio_sqr = (delta_lambdas / delta_lambda_l) ** 2.0

c1 = 2.0 * (1.0 - epsilon) / denominator
c2 = 0.5 * np.pi * epsilon / denominator

return c1 * np.sqrt(1.0 - lambda_ratio_sqr) + c2 * (1.0 - lambda_ratio_sqr)
\end{lstlisting}

